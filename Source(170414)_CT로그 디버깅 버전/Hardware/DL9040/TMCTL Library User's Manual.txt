********************************************************************************
	          TMCTL Library User's Manual
********************************************************************************


Foreword
Thank you for purchasing this YOKOGAWA software product.
This user's manual explains the requirements and methods for using the TMCTL.DLL library which
allows you to easily create programs for communications between the PC and our instruments.
To ensure proper use of the software, please read this manual thoroughly before beginning operation.
For information on the communications commands for performing actual communications control using
this library, please refer to the communications interface user's manual for your instrument.  

Note
The contents of this manual are subject to change without prior notice as a result of improvements
in the software's performance and functions.  

Trademarks
-  Microsoft, MS-DOS, Windows, Windows NT, Visual Basic, and Visual C++ are trademarks or registered
	trademarks of Microsoft Corporation in the United States and/or other countries.  
-  All other company and product names used in this manual are trademarks or registered trademarks of
	their respective companies.  
-  The company and product names used in this manual are not accompanied by the trademark or
	registered trademark symbols (R and TM).  

Revisions
May, 2001		1st Edition
July,2001		2nd Edition
Nov, 2002		3nd Edition
Oct, 2003		4th Edition
July,2004		5th Edition(start supporting the DL1700E series from this Edition)
June,2005  		6th Edition(start supporting the DL9000 series from this Edition)
Dec, 2006       7th Edition


Contents
1.  System Requirements
	1.1 OS and Programming Languages
	1.2 RAM
	1.3 Interfaces

2.  Compatible Instruments
	2.1 For GPIB
	2.2 For RS232
	2.3 For USB
	2.4 Ethernet

3.  Using the Library with Microsoft Visual C++
	3.1 Configuration
	3.2 Overview
	3.3 Available Functions
	3.4 Sample Programs

4.  Using the Library with Microsoft Visual Basic
	4.1 Configuration
	4.2 Overview
	4.3 Available Functions
	4.4 Sample Programs

5.  Error Codes




1.  System Requirements
	1.1  OS and Programming Languages
		OS: 			Windows 98(Second Edition), Windows Me, Windows 2000 or
					Windows XP
		Programming Languages: 	Microsoft Visual C++ 6.0
					Microsoft Visual Basic 6.0

	1.2  RAM
		32 MB or more

	1.3  Interfaces
		- GPIB:		An interface by National Instruments and its drivers.  
		- RS232:	An available serial port on your system.  
		- USB:		An interface with dedicated YOKOGAWA USB drivers installed.  
		- Ethernet:	A compatible interface.  
		- USBTMC:	This is only supported in the Windows 2000, XP OS when the 
				Yokogawa USBTMC device driver is installed. 

2.  Compatible Instruments 
	2.1  For GPIB: 	An instrument from YOKOGAWA equipped with an IEEE Standard 488.2 compliantGPIB interface.
			You may use other manufacturer's products,
			however some functions will be unavailable (see "Available Functions" in chapters 3 and 4
			for more details).
			Note: when using our instruments for communications, the terminator settings are usually
				set to LF and EOI, or EOI for transmitting binary data.  

	2.2  For RS232: An instrument from YOKOGAWA equipped with an RS232 interface and set from among the
			following settings:

			  Baud Rate: 
				- 1200, 2400, 4800, 9600, 19200, 38400, or 57600
			  Data bit length, parity, and stop bit:
				- 8 bit, no parity, 1 stop bit
				- 7 bit, even, 1 stop bit
				- 7 bit, odd, 1 stop bit
			  Handshaking:
				- NO-NO (no handshake)
				- XON-XON (software handshake)
				- CTS-RTS (hardware handshake)
			  Terminator: 
				- LF, CR+LF

			You may use other manufacturer's products, however some functions will be unavailable
			(see "Available Functions" in chapters 3 and 4 for more details).
			Note: normally, you can enter the following settings for communications using a YOKOGAWA
				instrument.
				  - 8 bit, no parity, 1 stop bit
				  - CTS-RTS (hardware handshake)
				  - Terminator: LF

	2.3  For USB:	YOKOGAWA's DL1740 Digital Oscilloscope (firmware version 1.10 or later), DL1720, DL750, DL1700E,
			DL7400, DL750P, DL1600, SL1400, the AQ7270 with an USB interface installed,
			or the WT3000 (firmware version 2.01 or later) with an USB interface installed.
			Note: the terminator settings should be LF and EOI, or EOI.  
				Do not turn the power OFF to either the PC or the DL while connected.  

	2.4  Ethernet:	YOKOGAWA's DL7100 Digital Oscilloscope (firmware version 3.02 or later), 
			DL7200 (firmware version 3.02 or later),
			DL1740 (firmware version 1.30 or later),
			DL9000 with an Ethernet interface installed,
			DL1720 with an Ethernet interface installed,
			DL750 with an Ethernet interface installed,
			DL750P with an Ethernet interface installed,
			DL1700E with an Ethernet interface installed,
			DL7400 with an Ethernet interface installed,
			DL1600 with an Ethernet interface installed,
			SL1400 with an Ethernet interface installed,
			WT1600 (firmware version 2.01 or later) with an Ethernet interface installed,
			or WT3000 (firmware version 2.01 or later) with an Ethernet interface installed.
			AQ7270 with an Ethernet interface installed,

	2.5  USBTMC:	YOKOGAWA's DL9000 Digital Oscilloscope
			Note: Please select either (LF & EOI ) or EOI as the terminator. 


3.  Using the Library with Microsoft Visual C++
	3.1  Configuration
		Files: 	Tmctl.h (header file for definitions of functions)
			Tmctl.lib (import library)
		- Type "tmctl.h" as the include file into to the source file you will use as follows:  
			#include "tmctl.h"
		- Copy Tmctl.lib to the directory containing the library files to be linked to.  
		- Copy Tmctl.dll to the Windows System directory.  
		- Copy Ykusb.dll to the Windows System directory if you will be using USB.  
		- Copy USBTMCAPI.dll to the Windows System directory if you will be using USBTMC.

	3.2  Overview
		This library uses an initialization function to set up a connection between the PC and devices to
		be controlled.  Then, values are returned as parameters and used as distinguishing IDs for the
		connected devices.  Those IDs can be passed to other functions (such as send/receive functions)
		to allow them to carry out their controls.  

	3.3  Available Functions
		---------------------------------------------------------------------------------------------------------------
		int TmcInitialize( int wire, char* adr, int* id );

		Purpose:	Initializes and opens a connection to the specified device
		Parameters:	int  wire	connection types
				char* adr	the address of the connection
				int*  id		special device ID used by other functions 
		Return value:	0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  int   wire
				Set this parameter to the type of connection through which the device will be
				controlled.
				The settings for each type of interface are shown below.  
					GPIB:		wire = 1
					RS232:		wire = 2
					USB:		wire = 3
					Ethernet:	wire = 4
					USBTMC:		wire = 5
			  char* adr
				Use a character string to set this parameter to the GPIB address or RS-232
				settings of the device to be controlled.
				The following shows how the settings for each interface.  
				GPIB:  adr = "1"-"30" (the GPIB address value of the device)
				RS232: adr = "port number, baud rate number, bit specification, handshaking number"  
					port number		1 = COM1
								2 = COM2
								3 = COM3
					baud rate number	0 = 1200
								1 = 2400
								2 = 4800
								3 = 9600
								4 = 19200
								5 = 38400
								6 = 57600
					bit specifications	0 = 8 bits, no parity, 1 stop bit
								1 = 7 bits, even parity, 1 stop bit
								2 = 7 bits, odd parity, 1 stop bit
					handshaking number	0 = NO-NO
								1 = XON-XON
								2= CTS-RTS
				USB: adr = "1"-"127" (the unique USB ID for the device)
				Ethernet: adr =	"server name, user name, password" 
					sever name		The server name or IP address of the DL
					user name		The user name 
					password		The password
	
							When the user name is anonymous,
								a password is not required.  
								(A delimiting comma "," is required.)
				USBTMC: adr = "serial number"
					where serial number is the serial number of the DL9000.
			  int* id
				Allocates the device ID passed to each function after initialization to the storage
				buffer.
				If initialization succeeds and a connection is opened, an integer equal to or greater
				than 0 is returned for the ID. 

				If initialization succeeds, the return value is 0. If a connection could not be opened,
				the return value is 1.  
				Regardless of the type of connection, the settings below take effect if initialization
				is successful.  
				- Terminator: LF (LF or EOI for GPIB)
				- Timeout: 30 seconds
		Example: 
			GPIB address 1:
				int id;
				int ret = TmcInitialize( 1, "1", &id );
			RS232 COM1,57600,8-NO-1,CTS-RTS:
				int id;
				ret = TmcInitialize( 2, "1,6,0,2", &id );
			USB ID 1:
				int id;
				int ret = TmcInitialize( 3, "1", &id );
			Ethernet IP = 11.22.33.44, User name = anonymous
				int id;
				int ret = TmcInitialize( 4, "11.22.33.44,anonymous,", &id );
			Ethernet IP = 11.22.33.44, User name = yokogawa, Password = abcdefgh
				int id;
				int ret = TmcInitialize( 4, "11.22.33.44,yokogawa,abcdefgh ", &id );
			USBTMC serial number = 27E000001
				int id;
				int ret = TmcInitialize( 5, "27E000001", &id );


		---------------------------------------------------------------------------------------------------------------
		int TmcDeviceClear( int id );

		Purpose:	Executes a selected device clear(SDC).  This is a GPIB-specific command.  
		Parameters:	int id  device ID
		Return value:	0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device for which the device clear will be executed.  
				This function is specific to GPIB devices, and doesn't affect devices using other
				interfaces.

			If device clear succeeds, the return value is 0.
			However, if it is executed on non-GPIB devices, the value is always 0.  
		Example: 
			int ret = TmcDeviceClear( id );

		---------------------------------------------------------------------------------------------------------------
		int TmcSend( int id, char* msg );

		Purpose:	Sends a message to a device.  
		Parameters:	int   id	device ID
				char* msg	message character string
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device to which the message will be sent.  
			  char* msg
				For this parameter, enter the character string for the message itself.  

			Sends an ASCII character string to the device specified by the ID.  
			When sending binary data, use "TmcSendByLength".  
			Also, when dividing up a message to be sent, use "TmcSendSetup" and "TmcSendOnly".  
		Example: 
			int ret = TmcSend( id, "START" );

		---------------------------------------------------------------------------------------------------------------
		int TmcSendByLength( int id, char* msg, int len );

		Purpose:	Sends a message of the specified number of bytes to a device.  
		Parameters:	int   id	device ID
				char* msg	message character string
				int   len	the length in bytes to be sent
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device to which the message will be sent.  
			  char* msg
				For this parameter, enter the message itself.  
			  int len
				Set this parameter to the number of bytes to be sent in the message.  

			Sends a message to the device specified by the ID.  
			You can send a message even if it includes binary data.  
			When dividing up a message to be sent, use "TmcSendSetup" and "TmcSendOnly".  
		Example: 
			int ret = TmcSendByLength( id, "START", 5 );

		---------------------------------------------------------------------------------------------------------------
		int TmcSendSetup( int id );

		Purpose:	Prepares the PC to send a message to a device.  
		Parameters:	int   id  device ID
		Return value:	0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device to which the PC should prepare to send a
				message.

			Prepares to send a message to the device specified by the ID.  
			When sending a single message over several transmissions, executes only once prior to the
			transmission.
			Use "TmcSendOnly" for the actual transmission.  
		Example: 
			int ret = TmcSendSetup( id );

		---------------------------------------------------------------------------------------------------------------
		int TmcSendOnly( int id, char* msg, int len, int end );

		Purpose:	Sends a message of the specified number of bytes to a device.  
		Parameters:	int   id		device ID
				char* msg	message character string
				int   len	the length in bytes to be sent
				int   end	end flag
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device to which the message will be sent.  
			  char* msg
				For this parameter, enter the message itself.  
			  int len
				Set this parameter to the number of bytes to be sent in the message.  
			  int end
				Set this parameter to indicate whether the current transmission is the final
				transmission.  
				The value is 1 at the end of transmission, or 0 if transmission is to continue.  

			Sends a message to the device specified by the ID.  
			You can send a message even if it includes binary data.  
			If the end flag was set to 1, a terminator is sent at the end of the message.  
			Therefore while the end flag is 0, the device side considers the message to be in a series.  
		Examples: 
			int ret;
			ret = TmcSendSetup( id );
			ret = TmcSendOnly( id, "STA", 3, 0 );
			ret = TmcSendOnly( id, "RT", 2, 1 );

		---------------------------------------------------------------------------------------------------------------
		int TmcReceive( int id, char* buff, int blen, int* rlen );

		Purpose:	Receives a message from a device.  
		Parameters:	int id  device ID
				char* buff	buffer for received data
				int   blen	size of the buffer (in bytes)
				int   rlen	the actual number of bytes received
		Return value:	 0 = OK, 1 = ERROR
		
		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device from which the message will be received.  
			  char* buff
				Set this parameter to create a buffer that will store the message.  
			  int blen
				Set this parameter to the maximum number of bytes in the message that may be
				received (normally the number of bytes in the buffer).  
			  int* rlen
				Returns the actual number of bytes received.  

			Receives a message from the device specified by the ID.  Receives data up to the terminator
			when one is detected, or the number of bytes specified by blen if no terminator is detected.  
			When using YOKOGAWA digital oscilloscopes, use "TmcReceiveBlockHeader" and
			"TmcReceiveBlockData" to receive message data such as "WAVeform:SEND?" and "IMAGe:SEND?".  
		Examples: 
			char buff[10000];
			int  length;
			int ret = TmcReceive( id, buff, 10000, &length );

		---------------------------------------------------------------------------------------------------------------
		int TmcReceiveSetup( int id );

		Purpose:	Prepares the PC to receive a message from a device.  
		Parameters:	int id  device ID
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device from which the PC will receive the
				message.  

			Executes in order to prepare to receive from the device large amounts of data that has
			been divided up into multiple transmissions.  
			Use "TmcReceiveOnly" for the actual receiving of data.  
		Example: 
			int ret = TmcReceiveSetup( id );

		---------------------------------------------------------------------------------------------------------------
		int TmcReceiveOnly( int id, char* buff, int blen, int* rlen );

		Purpose:	Receives a message (after preparation) from a device.  
		Parameters:	int id		device ID
				char* buff	buffer for received data
				int   blen	size of the buffer (in bytes)
				int   rlen	the actual number of bytes received
				Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device from which the message will be received.  
			  char* buff
				Set this parameter to create a buffer that will store the message.  
			  int blen
				Set this parameter to the maximum number of bytes in the message that may be
				received (normally the number of bytes in the buffer).  
			  int* rlen
				Returns the actual number of bytes received.  

			Used when receiving large amounts of data that has been divided up.  
			After preparing for reception using "TmcReceiveSetup", receives the message from the
			device specified by the ID.  
			Receives data up to the terminator when one is detected, or the number of bytes specified
			by blen if no terminator is detected.  
		Examples: 
			int	ret;
			char	buff [1000];
			int	length;

			ret = TmcReceiveSetup( id );
			ret = TmcReceiveOnly( id, buff, 1000, &length );
			ret = TmcReceiveOnly( id, buff, 1000, &length );
			ret = TmcReceiveOnly( id, buff, 1000, &length );

		---------------------------------------------------------------------------------------------------------------
		int TmcReceiveBlockHeader( int id, int* length );

		Purpose:	Receives the header portion of the Block Data sent from the device, and returns
				the number of bytes after the header.  
		Parameters:	int id		device ID
				int*  length	the number of bytes in the Block Data 
		Return value:	0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device from which Block Data will be received.  
			  int* length
				Returns the number of bytes in the Block Data.  


			This is the first command to be used before receiving Block Data.  
			The number of bytes in the data after the header is returned as the length, so that
			number plus 1 (for the terminator) is assigned to "TmcReceiveBlockData" and then the
			data is received.
		Examples: 
			int  length;
			int ret = TmcReceiveBlockHeader( id, &length );

		---------------------------------------------------------------------------------------------------------------
		int TmcReceiveBlockData( int id, char* buff, int blen, int* rlen, int* end );

		Purpose:	Receives the data portion of the Block Data sent from a device.  
		Parameters:	int id		device ID
				char* buff	buffer for received data
				int   blen	size of the buffer (in bytes)
				int   rlen	the actual number of bytes received
				int*  end	end flag
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device from which the message will be received.  
			  char* buff
				Set this parameter to create a buffer that will store the message.  
			  int blen
				Set this parameter to the maximum number of bytes in the message that may be
				received (normally the number of bytes in the buffer).  
			  int* rlen
				Returns the actual number of bytes received.  
			  int* end
				Returns whether all of the number of bytes of data returned by
				"TmcReceiveBlockHeader" are finished being received.  
				The value is 1 at the end of reception, or 0 if reception is to continue.  

			Used when receiving block data (messages starting with a #).  
			After preparing for reception using "TmcReceiveBlockHeader", the message is received
			from the device specified by the ID.  
			Receives data up to the terminator when one is detected, or the number of bytes specified
			by blen if no terminator is detected.  
		Example: 
			int	ret;
			int	length;
			int 	len;
			char	buff [1000];
			int	flag;
			ret = TmcReceiveBlockHeader( id, &length );
			if( length < 1 ) {
				return;
			}
			length += 1;
			flag = 0;
			while( flag == 0 ) {
				ret = TmcReceiveBlockData( id, buf, 1000, &len, &flag );
			}

		---------------------------------------------------------------------------------------------------------------
		int TmcCheckEnd( int id );

		Purpose:	Returns a value indicating whether the message from the device was completely received.
			  	Used with the GPIB, USB, Ethernet or USBTMC interface.  
		Parameters:	int id  device ID
		Return value:	 1 = message to continue, 0 = message complete

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device from which the message to be checked
				for completion will be received.  

			When receiving a message that has been divided up into a series of messages, all of the
			message is received using "TmcReveiveOnly", and the function returns the value indicating
			whether reception is complete.  
		Example: 
			int ret = TmcCheckEnd( id );
			if( ret == 0 ) {
				/* end of reception */
			}
			else {
				/* reception continuing */
			}

		---------------------------------------------------------------------------------------------------------------
		int TmcSetRen( int id, int flag );

		Purpose:	Places a device in remote or local mode.  Use with non-GPIB interfaces is limited to 
				YOKOGAWA instruments.  
		Parameters:	int id		device ID
				int  flag	remote (1)/local (0)
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device that will be placed in remote or
				local mode.  
			  int flag
				Send 1 for remote, and 0 for local mode.  

			Depending on the type of interface, there are some differences in the way this command
			is used.  
			For GPIB, the REN line is set to TRUE or FALSE.  
			Even after the parameter is entered, the device isn't actually placed in the mode until
			messages are sent to that device.  
			With GPIB, the remote/local function cannot be applied separately to different devices.  
			When using RS232, USB or Ethernet with YOKOGAWA 488.2 compliant devices, only devices
			that support COMMunications groups as messages can utilize this function.
			In this case, the function can be applied separately to different devices.  
			In the USBTMC, remote / local switch is realized by control transfer. 
		Example:
			int ret = TmcSetRen( id, 1 );

		---------------------------------------------------------------------------------------------------------------
		int TmcGetLastError( int id );

		Purpose:	Returns the number of the last error that occurred.  
		Parameters:	int id  device ID
		Return value:	Error number

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device from which an error number will
				be acquired.  

			Returns the number of the last error that occurred on that device.  
			If the return value from any of the functions is non-zero (including the initialization
			function), this function can be used to acquire the actual error number.  
		Example: 
			int ret = TmcSend( id, "START" );
			if( ret != 0 ) {
				int err = TmcGetLastError( id );
			}

		---------------------------------------------------------------------------------------------------------------
		int TmcSetTerm( int id, int eos, int eot );

		Purpose:	Sets the terminator for sending or receiving a message.  
		Parameters:	int id		device ID
				int  eos	terminator
				int  eot  EOI
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device for the terminator.  
			  int eos
				Set this parameter to the terminator itself.  The settings are shown below.  
				eos = 0 : CR+LF
				    = 1 : CR
				    = 2 : LF
				    = 3 : EOI (GPIB), or not (RS232, USB, Ethernet)
				When the interface is GPIB and eos is 3, eot determines whether EOI is used.  
			  int eot
				Set this parameter to determine whether EOI can be used for the terminator.
				This is a GPIB-specific command.  

			Sets the terminator.  In general, you can use the following settings for any interface
			when carrying out communications with YOKOGAWA products.  
			   int ret = TmcSetTerm( id, 2, 1 ); /* eos = LF, eot = TRUE */
			When sending or receiving binary data with the setting eos = LF, if LF code is included
			in the binary code, the transmission concludes when the LF code is encountered.  
			However, when receiving block data using a YOKOGAWA product, if you use
			"TmcReceiveBlockHeader" and "TmcReceivceBlockData", there's no need to switch the
			terminator.  
		Example: 
			int ret = TmcSetTerm( id, 2, 1 );

		---------------------------------------------------------------------------------------------------------------
		int TmcSetTimeout( int id, int tmo );

		Purpose:	Sets the timeout time for communications.  
		Parameters:	int id		device ID
				int  tmo	timeout time (100-6553600 ms)
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device on which timeout will be set.  
			  int tmo
				Set this parameter to the timeout time in units of 100 ms. 		
				When tmo = 0
					GPIB:  Timeout unlimited
					Other: No timeout 

			Sets the timeout time for communications.  Generally you should set the timeout time
			to 30 seconds when using YOKOGAWA products.  (Even if you lengthen the timeout time,
			performance will not be affected.)  
		Example: 
			int ret = TmcSetTimeout( id, 300 );	/* 30s */

		---------------------------------------------------------------------------------------------------------------
		int TmcFinish( int id );

		Purpose:	Closes the connection to a device.  
		Parameters:	int id  device ID
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  int id
				Set this parameter to the ID of the device whose connection will be closed.  

			Closes connections opened with "TmcInitialize" (initialization function).  
			You must execute this function when concluding communications.  
		Example: 
			int ret = TmcFinish( id );

		---------------------------------------------------------------------------------------------------------------

	3.4  Sample Programs

		#include "tmctl.h"

		int ExecuteCommunicate( void )
		{
			char adr[100];
			int  ret;
			int  id;
			char buf[1000];
			int  length;

			// Example 1: GPIB address = 1
			ret = TmcInitialize( 1, "1", &id );
			// Example 2: RS232 COM1, 57600, 8-NO-1, CTS-RTS
			ret = TmcInitialize( 2, "1,6,0,1", &id );
			// Example 3: USB ID = 1
			ret = TmcInitialize( 3, "1", &id );
			// Example 4: Ethernet IP = 11.22.33.44,User name = yokogawa,Password = abcdefgh
			ret = TmcInitialize( 4, "11.22.33.44,yokogawa,abcdefg", &id );
			// Example 5: USBTMC Serial Number = 27E000001
			ret = TmcInitialize( 5, "27E000001", &id );
			if( ret != 0 ) {
				return	TmcGetLastError( id );
			}
			ret = TmcSetTerm( id, 2, 1 );
			if( ret != 0 ) {
				return	TmcGetLastError( id );
			}
			ret = TmcSetTimeout( id, 300 );
			if( ret != 0 ) {
				return	TmcGetLastError( id );
			}


			ret = TmcSetRen( id, 1 );
			if( ret != 0 ) {
				return	TmcGetLastError( id );
			}

			/* sending *RST */
			ret = TmcSend( id, "*RST" );
			if( ret != 0 ) {
				return	TmcGetLastError( id );
			}

			/* *sending IDN? & receiving query */
			ret = TmcSend( id, "*IDN?" );
			if( ret != 0 ) {
				return	TmcGetLastError( id );
			}

			ret = TmcReceive( id, buf, 1000, &length );
			if( ret != 0 ) {
				return	TmcGetLastError( id );
			}
		}


4.  Using the Library with Microsoft Visual Basic
	4.1  Configuration
		Files:	Tmctl.bas (file for definitions of functions)
			Tmval.bas (file for definitions of constants)
		- Copy Tmctl.bas and Tmval.bas to the standard module of the project you will be using.  
		- Copy Tmctl.dll to the Windows system directory.  
		- Copy Ykusb.dll to the Windows System directory if you will be using USB.  
		- Copy USBTMCAPI.dll to the Windows System directory if you will be using USBTMC.  

	4.2  Overview
		This library uses an initialization function to set up a connection between the PC and devices
 		to be controlled.  Then, values are returned as parameters and used as distinguishing IDs for 
		the connected devices.  Those IDs can be passed to other functions (such as send/receive 	
		functions) to allow them to carry out their controls.  

	4.3  Available Functions
		---------------------------------------------------------------------------------------------------------------
		TmInitialize(ByVal wire As Long, ByVal adr As String, ByRef id As Long) As Long

		Purpose:	Initializes and opens a connection to the specified devices
		Parameters:	Long  wire  connection types
				String adr	the address of the connection
				Long  id	special device ID used in other commands 
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long   wire
		
		Set this parameter to the type of wire with which the device to be controlled
				is connected.  
				The settings for each type of interface are shown below.  
					GPIB :		wire = 1
					RS232 :		wire = 2
					USB :    	wire = 3
					Ethernet : 	wire = 4
					USBTMC :	wire = 5
			  String adr
				Enter a character string to set this parameter to the GPIB address or RS-232
				settings for the device to be controlled. 
				The following shows the settings for each interface.  
				GPIB:  adr = "1"-"30" (the GPIB address value of the device)
				RS232: adr = "port number, baud rate number, bit specification, handshaking number"  
					port number		1 = COM1
								2 = COM2
								3 = COM3
					baud rate number	0 = 1200
								1 = 2400
								2 = 4800
								3 = 9600
								4 = 19200
								5 = 38400
								6 = 57600
					bit specifications	0 = 8 bits, no parity, 1 stop bit
								1 = 7 bits, even parity, 1 stop bit
								2 = 7 bits, odd parity, 1 stop bit
					handshaking no.		0 = NO-NO
								1 = XON-XON
								2= CTS-RTS
				USB: adr = "1-127" (the USB ID for the device)
				Ethernet: adr = "server name,user name,password" 
					sever name	The server name or IP address of the DL
					user name	The user name 
					password	The password
							When the user name is anonymous,
							a password is not required.  
							(A delimiting comma "," is required.)
				USBTMC: adr = "serial number"
					where serial number is the serial number of the DL9000.
			  Long id
				Allocates the device ID passed to each function after initialization to the
				storage buffer. If initialization succeeds and a connection is opened, an
				integer greater than or equal to 0 is returned for the ID.  

			If initialization succeeds, the return value is 0.  If a connection could not be opened,
			the return value is 1.  
			Regardless of the type of connection, the settings below take effect if initialization
			is successful.  
			- Terminator: LF (LF or EOI for GPIB)
			- Timeout: 30 seconds
		Example: 
			GPIB address 1:
				Dim id As Long
				Dim ret As Long
				Dim adr As String
				adr = "1"
				ret = TmInitialize( 1, adr, id )
			RS232 COM1,57600,8-NO-1,CTS-RTS:
				Dim id As Long
				Dim ret As Long
				Dim adr As String
				adr = "1,6,0,2"
				ret = TmInitialize( 2, adr, id )
			USB ID 1:
				Dim id As Long
				Dim ret As Long
				Dim adr As String
				adr = "1"
				ret = TmcInitialize( 3, adr, id )
			Ethernet IP = 11.22.33.44, User name = anonymous:
				Dim id As Long
				Dim ret As Long
				Dim adr As String
				adr = "11.22.33.44,anonymous,"
				ret = TmInitialize( 4, adr, id )
			Ethernet IP = 11.22.33.44, User name = yokogawa, Password = abcdefgh:
				Dim id As Long
				Dim ret As Long
				Dim adr As String
				adr = "11.22.33.44,yokogawa,abcdefgh"
				ret = TmInitialize( 4, adr, id )
			USBTMC Serial Number = 27E000001:
				Dim id As Long
				Dim ret As Long
				Dim adr As String
				adr = "27E000001"
				ret = TmcInitialize( 5, adr, id )

		---------------------------------------------------------------------------------------------------------------
		TmDeviceClear(ByVal id As Long) As Long

		Purpose:	Executes a selected device clear(SDC).  This is a GPIB-specific command.  
		Parameters:	Long id  device ID
		Return value:	0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device on which the device clear will
				be executed.  This function is specific to GPIB devices, and doesn't affect
				devices using other interfaces.  

			If device clear succeeds, the return value is 0.
			However, if it is executed on non-GPIB devices, the value is always 0.  
		Example: 
			Dim ret As Long
			ret = TmDeviceClear( id )

		---------------------------------------------------------------------------------------------------------------
		TmSend(ByVal id As Long, ByVal msg As String) As Long

		Purpose:	Sends a message to a device.  
		Parameters:	Long   id	device ID
				String msg	message character string
		Return value:	0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device to which the message will be sent.  
			  String msg
				For this parameter, enter the character string for the message itself.  

			Sends an ASCII character string to the device specified by the ID.  When sending binary
			data, use "TmcSendByLength".  Also, when dividing up a message to be sent,
			use "TmSendSetup" and "TmSendOnly".  
		Example: 
			Dim ret As Long
			ret = TmSend( id, "START" )

		---------------------------------------------------------------------------------------------------------------
		TmSendByLength(ByVal id As Long, ByVal msg As String, ByVal blen As Long) As Long

		Purpose:	Sends a message of the specified number of bytes to a device.  
		Parameters:	Long   id	device ID
				String msg	message character string
				Long   len	the length in bytes to be sent
		Return value:	 0 = OK, 1 = ERROR


		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device to which the message will be sent.  
			  Byte msg()
				For this parameter, enter the message itself.  
			  Long len
				Set this parameter to the number of bytes sent in the message.  

			Sends a message to the device specified by the ID.
			Also, when dividing up a message to be sent, use "TmSendSetup" and "TmSendOnly".  
		Example: 
			Dim ret As Long
			ret = TmSendByLength( id, "START", 5 )

		---------------------------------------------------------------------------------------------------------------
		TmSendByLengthB(ByVal id As Long, ByRef msg() As Byte, ByVal blen As Long) As Long

		Purpose:	Sends a message(byte array) of the specified number of bytes to a device.

		Parameters:	Long   id	device ID
				Byte   msg()	message byte array
				Long   len	the length in bytes to be sent
		Return value:	 0 = OK, 1 = ERROR


		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device to which the message will be sent.  
			  Byte msg()
				For this parameter, enter the message itself.  
			  Long len
				Set this parameter to the number of bytes sent in the message.  

			Sends a message to the device specified by the ID.  You can send a message even if
			it includes binary data.  Also, when dividing up a message to be sent, use
			"TmSendSetup" and "TmSendOnlyB".  
		Example: 
			Dim ret As Long
			Dim msg(10) As Byte
			
			msg(0) = CByte(Asc("S"))
			msg(1) = CByte(Asc("T"))
			msg(2) = CByte(Asc("A"))
			msg(3) = CByte(Asc("R"))
			msg(4) = CByte(Asc("T"))
			ret = TmSendByLengthB( id, msg, 5 )

		---------------------------------------------------------------------------------------------------------------
		TmSendSetup(ByVal id As Long) As Long

		Purpose:	Prepares the PC to send a message to a device.  
		Parameters:	Long   id  device ID
		Return value:	0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device to which the PC should prepare
				to send a message.  

			Prepares to send a message to the device specified by the ID.  
			When sending a single message over several transmissions, executes only once prior to the
			transmission.
			Use "TmSendOnly" for the actual transmission.  
		Example: 
			Dim ret As Long
			ret = TmSendSetup( id )

		---------------------------------------------------------------------------------------------------------------
		TmSendOnly(ByVal id As Long, ByVal msg As String, ByVal len As Long, ByVal end As Long)	As Long

		Purpose:	Sends a message of the specified number of bytes to a device.  
		Parameters:	Long   id	device ID
				String msg	message character string
				Long   len	the length in bytes to be sent
				Long   end	end flag
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device to which the message will be sent.  
			  String msg
				For this parameter, enter the message itself.  
			  Long len
				Set this parameter to the length in bytes to be sent.  
			  Long end
				Set this parameter to indicate whether the current transmission is the final
				transmission.  
				The value is 1 at the end of transmission, or 0 if transmission is to continue.  

			Sends a message to the device specified by the ID.  You can send a message even if it
			includes binary data.  If the end flag was set to 1, a terminator is sent at the end of
			the message.  Therefore while the end flag is 0, the device side considers the message
			to be in a series.  
		Example: 
			Dim ret As Long
			ret = TmSendSetup( id )
			ret = TmSendOnly( id, "STA", 3, 0 )
			ret = TmSendOnly( id, "RT", 2, 1 )

		---------------------------------------------------------------------------------------------------------------
		TmSendOnlyB((ByVal id As Long, ByRef buf() As Byte, ByVal blen As Long, ByVal ed As Long) As Long

		Purpose:	Sends a message(byte array) of the specified number of bytes to a device.

		Parameters:	Long   id	device ID
				Byte   msg()	message byte array
				Long   len	the length in bytes to be sent
				Long   end	end flag
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device to which the message will be sent.  
			  Byte msg()
				For this parameter, enter the message itself.  
			  Long len
				Set this parameter to the length in bytes to be sent.  
			  Long end
				Set this parameter to indicate whether the current transmission is the final
				transmission.  
				The value is 1 at the end of transmission, or 0 if transmission is to continue.  

			Sends a message to the device specified by the ID.  You can send a message even if it
			includes binary data.  If the end flag was set to 1, a terminator is sent at the end of
			the message.  Therefore while the end flag is 0, the device side considers the message
			to be in a series.  
		Example: 
			Dim ret As Long
			Dim msg(10) As Byte
			
			ret = TmSendSetup( id )
			msg(1) = CByte(Asc("S"))
			msg(2) = CByte(Asc("T"))
			msg(3) = CByte(Asc("A"))
			ret = TmSendOnlyB( id, msg, 3, 0 )
			msg(1) = CByte(Asc("R"))
			msg(2) = CByte(Asc("T"))
			ret = TmSendOnlyB( id, msg, 2, 1 )

		---------------------------------------------------------------------------------------------------------------
		TmReceive(ByVal id As Long, ByRef buf As String, ByVal blen As Long, ByRef rlen As Long) As Long

		Purpose:	Receives a message from a device as a character string.  
		Parameters:	Long id		device ID
				String buf	buffer for received data
				Long   blen	size of the buffer (in bytes)
				Long   rlen	the actual number of bytes received
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device from which the message will be received.  
			  String buf
				Set this parameter to the create a buffer that will store the message.  
			  Long blen
				Set this parameter to the maximum number of bytes in the message that may be
				received (normally the number of bytes in the buffer).  
			  Long rlen
				Returns the actual number of bytes received.  

			Receives a message from the device specified by the ID.  Receives data up to the
			terminator when one is detected, or the number of bytes specified by blen if no
			terminator is detected.  When using YOKOGAWA digital oscilloscopes,
			use "TmReceiveBlockHeader","TmReceiveBlock", and "TmReceiveBlockB" to receive message data
		 	such as "WAVeform:SEND?" and "IMAGe:SEND?".  
		Example: 
			Dim ret As Long
			Dim buf As String
			Dim length As Long
			buf = Space$(1000)
			ret = TmReceive( id, buf, 1000, length )

		---------------------------------------------------------------------------------------------------------------
		TmReceiveSetup(ByVal id As Long) As Long

		Purpose:	Prepares the PC to receive a message from a device.  
		Parameters:	Long id  device ID
		Return value:	0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device from which the PC will receive the
				message.  

			Executed in order to prepare the PC to receive from the device large amounts of data
			that has been divided up into multiple transmissions.  Use "TmReceiveOnly" for the
			actual data transmission.  
		Example: 
			Dim ret As Long
			int ret = TmReceiveSetup( id );

		---------------------------------------------------------------------------------------------------------------
		TmReceiveOnly(ByVal id As Long, ByRef buf As String, ByVal blen As Long, ByRef rlen As Long) As Long

		Purpose:	Receives a message (after preparation) from a device as a character string.  
		Parameters:	Long id		device ID
				String buf	buffer for received data
				Long   blen	size of the buffer (in bytes)
				Long   rlen	the actual number of bytes received
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device from which the message will be received.  
			  String buf
				Set this parameter to create a buffer that will store the message.  
			  Long blen
				Set this parameter to the maximum number of bytes in the message that may be
				received (normally the number of bytes in the buffer).  
			  Long rlen
				Returns the actual number of bytes received.  

			Used when receiving large amounts of data that has been divided up.  
			After preparing for reception using "TmReceiveSetup", receives the message from the
			device specified by the ID.  
			Receives data up to the terminator when one is detected, or the number of bytes
			specified by blen if no terminator is detected.  
		Example: 
			Dim ret As Long
			Dim buf As String
			Dim length As Long

			ret = TmReceiveSetup( id )
			buf = Space$(1000)
			ret = TmReceiveOnly( id, buf, 1000, &length )
			buf = Space$(1000)
			ret = TmReceiveOnly( id, buf, 1000, &length )
			buf = Space$(1000)
			ret = TmReceiveOnly( id, buf, 1000, &length )

		---------------------------------------------------------------------------------------------------------------
		TmReceiveBlockHeader(ByVal id As Long, ByRef len As Long) As Long

		Purpose:	Receives the header portion of the Block Data sent from the device, and returns the number of bytes of the data after the header.  
		Parameters:	Long id		device ID
				Long   len	the number of bytes in the Block Data 
		Return value:	0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device from which Block Data will be received.  
			  Long length
				Returns the number of bytes in the Block Data.  

			This is the first command to be used before receiving Block Data.  
			The number of bytes in the data after the header is returned for len, so that
			number plus 1 (for the terminator) is assigned to "TmReceiveBlock" and
			"TmReceiveBlockB", then the data is received.  
		Example: 
			Dim ret As Long
			Dim length As Long
			ret = TmcReceiveBlockHeader( id, length );

		---------------------------------------------------------------------------------------------------------------
		TmReceiveBlock(ByVal id As Long, buf() As Integer, ByVal blen As Long, ByRef rlen As Long, ByRef end As Long) As Long

		Purpose:	Receives the data portion of the Block Data sent from a device into an integer array.
		Parameters:	Long id			device ID
				Integer   buf ()	buffer for received data
				Long   blen		size of the buffer (in bytes)
				Long   rlen		the actual number of bytes received
				Long   end		end flag
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device from which the message will be received.  
			  Integer buf()
				Set this parameter to create a integer array that will store the message.  
			  Long blen
				Set this parameter to the maximum number of bytes in the message that may be
				received (normally the number of bytes in the buffer).  
			  Long rlen
				Returns the actual number of bytes received.  
			Long end
				Returns whether all of the number of bytes of data returned by
				"TmReceiveBlockHeader" are received.  
				The value is 1 at the end of reception, or 0 if reception is to continue.  

			Used when receiving block data (message starting with #-).
			After preparing for reception using "TmReceiveBlockHeader", the message is received
			from the device specified by the ID.  Receives data up to the terminator when one
			is detected, or the number of bytes specified by blen if no terminator is detected.  
		Example: 
			Dim ret As Long
			Dim buf(1000) As Integer
			Dim length As Long
			Dim rlen As Long
			Dim flag As Long

			ret = TmReceiveBlockHeader( id, length )
			length = length + 1
			flag = 0
			While (flag = 0)
				ret = TmReceiveBlock( id, buf(), 2000, rlen, flag )
			Wend

		---------------------------------------------------------------------------------------------------------------
		TmReceiveBlockB(ByVal id As Long, buf() As Byte, ByVal blen As Long, ByRef rlen As Long, ByRef end As Long) As Long

		Purpose:	Receives the data portion of the Block Data sent from a device into a byte array.  
		Parameters:	Long id		device ID
				Byte   buf()	buffer for received data
				Long   blen	size of the buffer (in bytes)
				Long   rlen	the actual number of bytes received
				Long   end	end flag
		Return value:	0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device from which the message will be received.  
			  Byte buf()
				Set this parameter to create a byte array that will store the message.  
			  Long blen
				Set this parameter to the maximum number of bytes in the message that may
				be received (normally the number of bytes in the buffer).  
			  Long rlen
				Returns the actual number of bytes received.  
			  Long end
				Returns whether all of the number of bytes of data returned by
				"TmReceiveBlockHeader" are received.  
				The value is 1 at the end of reception, or 0 if reception is to continue.  

			Used when receiving block data (message starting with #-).  
			After preparing for reception using "TmReceiveBlockHeader", receives the message
			from the device specified by the ID.  Receives data up to the terminator when one
			is detected, or the number of bytes specified by blen if no terminator is detected.  
		Example: 
			Dim ret As Long
			Dim buf(1000) As Byte
			Dim length As Long
			Dim rlen As Long
			Dim flag As Long

			ret = TmReceiveBlockHeader( id, length )
			length = length + 1
			flag = 0
			While (flag = 0)
				ret = TmReceiveBlockB( id, buf(), 1000, rlen, flag )
			Wend

		---------------------------------------------------------------------------------------------------------------
		TmCheckEnd(ByVal id As Long) As Long

		Purpose:	Returns a value indicating whether the message from the device was completely received.  
				Used with the GPIB, USB, Ethernet or USBTMC interface.  
		Parameters:	Long id  device ID
		Return value:	1 = message to continue, 0 = message complete

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device from which the message to be
				checked for completion was received.  

			When receiving a message that has been divided up into a series of messages,
			all of the message is received using "TmReceiveOnly", and "TmReceiveOnlyBin"
			and the function returns the value indicating whether reception is complete.  
		Example: 
			Dim ret As Long
			ret = TmCheckEnd( id );
			If( ret == 0 ) Then
				'end of reception
			Else
				'reception continuing
			Endif

		---------------------------------------------------------------------------------------------------------------
		TmSetRen(ByVal id As Long, ByVal flg As Long) As Long

		Purpose:	Places a device in remote or local mode.  Use with non-GPIB interfaces is limited to YOKOGAWA instruments.  
		Parameters:	Long id		device ID
				Long  flg	remote (1)/local (0)
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device that will be placed in remote or
				local mode.  
			  Long flg
				Send 1 for remote, and 0 for local mode.  

			Depending on the type of interface, there are some differences in the way this
			command is used.  
			For GPIB, the REN line is set to TRUE or FALSE.  
			Even after the remote parameter is entered, the device isn't actually placed in
			the mode until messages are sent to that device.
			With GPIB, the remote/local function cannot be applied separately to different devices.
			When using RS232, USB and Ethernet with YOKOGAWA 488.2 compliant products,
			only devices that support COMMunicate groups as messages can process this function.
			If your system complies, the function can be applied separately to different devices.  
			In the USBTMC, remote / local switch is realized by control transfer. 
		Example: 
			Dim ret As Long
			ret = TmSetRen( id, 1 );

		---------------------------------------------------------------------------------------------------------------
		TmGetLastError(ByVal id As Long) As Long

		Purpose:	Returns the number of the last error that occurred.  
		Parameters:	Long id  device ID
		Return value:	Error number

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device from which the error number
				is acquired.  

			Returns the number of the last error that occurred on that device.  
			If the return value from any of the functions is non-zero (including the initialization
			function), this function can be used to acquire the actual error number.  
		Example: 
			Dim ret As Long
			Dim err As Long

			ret = TmSend( id, "START" );
			If( ret != 0 ) Then
				err = TmGetLastError( id );
			Endif

		---------------------------------------------------------------------------------------------------------------
		TmSetTerm(ByVal id As Long, ByVal eos As Long, ByVal eot As Long) As Long

		Purpose:	Sets the terminator for sending or receiving a message.  
		Parameters:	Long id		device ID
				Long  eos	terminator
				Long  eot	EOI
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device for the terminator.  
			  Long  eos 
				Set this parameter to the terminator itself.  The settings are shown below.  
				eos = 0 : CR+LF
				    = 1 : CR
				    = 2 : LF
				    = 3 : EOI (GPIB), or not (RS232, USB, Ethernet)
				When the interface is GPIB and eos is 3, eot determines whether EOI is used.  
			  Long  eot 
				Set this parameter to determine whether EOI can be used for the terminator.
				This is a GPIB-specific command.  

			Sets the terminator.  In general, you can use the following settings for any interface
			when carrying out communications with YOKOGAWA products.  
				Dim ret As Long
				ret = TmSetTerm( id, 2, 1 );  'eos = LF, eot = TRUE
			When sending or receiving binary data with the setting eos = LF, if LF code is included
			in the binary code, the transmission concludes when the LF code is encountered.
			However, when receiving block data using a YOKOGAWA product, if you use
			"TmReceiveBlockHeader", "TmReceivceBlock", and "TmReceivceBlockB", there's no need to
			switch the terminator.  
		Example: 
			Dim ret As Long
			ret = TmSetTerm( id, 2, 1 );

		---------------------------------------------------------------------------------------------------------------
		TmSetTimeout(ByVal id As Long, ByVal tmo As Long) As Long

		Purpose:	Sets the timeout time for communications.  
		Parameters:	Long id		device ID
				Long  tmo	timeout time (100-6553600 ms)
		Return value:	 0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device on which timeout will be set.  
			  Long tmo
				Set this parameter to the timeout time in units of 100 ms. 
				When tmo = 0,
					GPIB: Timeout unlimited
					Other: No timeout 

			Sets the timeout time for communications.  
			Generally you should set the timeout time to 30 seconds when using YOKOGAWA products.  
			(Even if you lengthen the timeout time, performance will not be affected.)  
		Example: 
			Dim ret As Long
			ret = TmSetTimeout( id, 300 )	'30s

		---------------------------------------------------------------------------------------------------------------
		TmFinish(ByVal id As Long) As Long

		Purpose:	Closes the connection to a device.  
		Parameters:	Long id  device ID
		Return value:	0 = OK, 1 = ERROR

		Details:
			Description of Parameters
			  Long id
				Set this parameter to the ID of the device whose connection will be closed.  

			Closes connections opened with "TmInitialize" (initialization function).  
			You must execute this function when concluding communications.  
		Example: 
			Dim ret As Long
			ret = TmcFinish( id );

		---------------------------------------------------------------------------------------------------------------


	4.4  Sample Programs

		Function ExecuteCommunicate
			Dim adr As String
			Dim ret As Long
			Dim id As Long
			Dim buf As String
			Dim length As Long

			'Example 1: GPIB address = 1
			adr = "1"
			ret = TmInitialize( 1, adr, id )
			'Example 2: RS232 COM1, 57600, 8-NO-1, CTS-RTS
			adr = "1,6,0,2"
			ret = TmInitialize( 2, adr, id )
			'Example 3: USB ID = 1
			adr = "1"
			ret = TmInitialize( 3, adr, id )
			'Example 4: Ethernet IP = 11.22.33.44, User name = yokogawa, Password = abcdefgh
			adr = "11.22.33.44,yokogawa,abcdefgh"
			ret = TmInitialize( 4, adr, id )
			'Example 5: USBTMC Serial Number = 27E000001
			adr = "27E000001"
			ret = TmInitialize( 4, adr, id )
			If( ret <> 0 ) Then
				ExecuteCommunicate = TmGetLastError( id )
				Exit Function
			Endif
			ret = TmSetTerm( id, 2, 1 )
			If( ret <> 0 ) Then
				ExecuteCommunicate = TmGetLastError( id )
				Exit Function
			Endif
			ret = TmSetTimeout( id, 300 )
			If( ret <> 0 ) Then
				ExecuteCommunicate = TmGetLastError( id )
				Exit Function
			Endif

			ret = TmSetRen( id, 1 )
			If( ret <> 0 ) Then
				ExecuteCommunicate = TmGetLastError( id )
				Exit Function
			Endif

			'sending *RST
			ret = TmSend( id, "*RST" )
			If( ret <> 0 ) Then
				ExecuteCommunicate = TmGetLastError( id )
				Exit Function
			Endif

			'*sending IDN? & receiving query
			ret = TmSend( id, "*IDN?" )
			If( ret <> 0 ) Then
				ExecuteCommunicate = TmGetLastError( id )
				Exit Function
			Endif
			buf = Space$(1000)
			ret = TmReceive( id, buf, 1000, &length )
			If( ret <> 0 ) Then
				ExecuteCommunicate = TmGetLastError( id )
				Exit Function


			Endif
			ExecuteCommunicate = 0
		End Function


5.  Error Codes
	Error number	Problem			Solutions
	2		Device not found		Check the wiring.  
	4		Connection to device failed	Check the wiring.  
	8		Device not connected		Connect the device using the initialization function.  
	16		Device already connected	Two connections cannot be opened.  
	32		Incompatible PC		Check the hardware you are using.  
	64		Illegal parameter		Check parameter type etc.  
	256		Send error			Check the wiring, address, and ID.  
	512		Receive error			Check whether an error occurred on the device.  
	1024		Received data not block data  
	4096		System error  			There is a problem with the operating environment.  
	8192		Illegal device ID  		Use the ID of the device acquired by the initialization function.  

